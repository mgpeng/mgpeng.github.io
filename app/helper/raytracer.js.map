{"version":3,"file":"raytracer.js","sourceRoot":"","sources":["raytracer.ts"],"names":[],"mappings":"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","sourcesContent":["// class Vector {\n\n//     constructor(public x: number, public y: number, public z: number) { }\n\n//     static times(k: number, v: Vector) {\n//         return new Vector(k * v.x, k * v.y, k * v.z);\n//     }\n\n//     static minus(v1: Vector, v2: Vector) {\n//         return new Vector(v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);\n//     }\n\n//     static plus(v1: Vector, v2: Vector) {\n//         return new Vector(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);\n//     }\n\n//     static dot(v1: Vector, v2: Vector) {\n//         return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n//     }\n\n//     static mag(v: Vector) {\n//         return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n//     }\n\n//     static norm(v: Vector) {\n//         let mag = Vector.mag(v);\n//         let div = (mag === 0) ? Infinity : 1.0 / mag;\n//         return Vector.times(div, v);\n//     }\n\n//     static cross(v1: Vector, v2: Vector) {\n//         return new Vector(v1.y * v2.z - v1.z * v2.y,\n//                           v1.z * v2.x - v1.x * v2.z,\n//                           v1.x * v2.y - v1.y * v2.x);\n//     }\n\n// }\n\n// class Color {\n\n//     constructor(public r: number, public g: number, public b: number) { }\n\n//     static scale(k: number, v: Color) {\n//         return new Color(k * v.r, k * v.g, k * v.b);\n//     }\n\n//     static plus(v1: Color, v2: Color) {\n//         return new Color(v1.r + v2.r, v1.g + v2.g, v1.b + v2.b);\n//     }\n\n//     static times(v1: Color, v2: Color) {\n//         return new Color(v1.r * v2.r, v1.g * v2.g, v1.b * v2.b);\n//     }\n\n//     static white = new Color(1.0, 1.0, 1.0);\n//     static grey = new Color(0.5, 0.5, 0.5);\n//     static black = new Color(0.0, 0.0, 0.0);\n//     static background = Color.black;\n//     static defaultColor = Color.black;\n\n//     static toDrawingColor(c: Color) {\n//         let legalize = d => d > 1 ? 1 : d;\n//         return {\n//             r: Math.floor(legalize(c.r) * 255),\n//             g: Math.floor(legalize(c.g) * 255),\n//             b: Math.floor(legalize(c.b) * 255)\n//         }\n//     }\n\n// }\n\n// class Camera {\n\n//     forward: Vector;\n//     right: Vector;\n//     up: Vector;\n\n//     constructor(public pos: Vector, lookAt: Vector) {\n//         let down = new Vector(0.0, -1.0, 0.0);\n//         this.forward = Vector.norm(Vector.minus(lookAt, this.pos));\n//         this.right = Vector.times(1.5, Vector.norm(Vector.cross(this.forward, down)));\n//         this.up = Vector.times(1.5, Vector.norm(Vector.cross(this.forward, this.right)));\n//     }\n\n// }\n\n// interface Ray {\n//     start: Vector;\n//     dir: Vector;\n// }\n\n// interface Intersection {\n//     thing: Thing;\n//     ray: Ray;\n//     dist: number;\n// }\n\n// interface Surface {\n//     diffuse: (pos: Vector) => Color;\n//     specular: (pos: Vector) => Color;\n//     reflect: (pos: Vector) => number;\n//     roughness: number;\n// }\n\n// interface Thing {\n//     intersect: (ray: Ray) => Intersection;\n//     normal: (pos: Vector) => Vector;\n//     surface: Surface;\n// }\n\n// interface Light {\n//     pos: Vector;\n//     color: Color;\n// }\n\n// interface Scene {\n//     things: Thing[];\n//     lights: Light[];\n//     camera: Camera;\n// }\n\n// class Sphere implements Thing {\n\n//     radius2: number;\n\n//     constructor(public center: Vector, radius: number, public surface: Surface) {\n//         this.radius2 = radius * radius;\n//     }\n\n//     normal(pos: Vector): Vector {\n//         return Vector.norm(Vector.minus(pos, this.center));\n//     }\n\n//     intersect(ray: Ray) {\n//         let eo = Vector.minus(this.center, ray.start);\n//         let v = Vector.dot(eo, ray.dir);\n//         let dist = 0;\n//         if (v >= 0) {\n//             let disc = this.radius2 - (Vector.dot(eo, eo) - v * v);\n//             if (disc >= 0) {\n//                 dist = v - Math.sqrt(disc);\n//             }\n//         }\n//         if (dist === 0) {\n//             return null;\n//         } else {\n//             return { thing: this, ray: ray, dist: dist };\n//         }\n//     }\n\n// }\n\n// class Plane implements Thing {\n\n//     normal: (pos: Vector) => Vector;\n//     intersect: (ray: Ray) => Intersection;\n\n//     constructor(norm: Vector, offset: number, public surface: Surface) {\n//         this.normal = function(pos: Vector) { return norm; }\n//         this.intersect = function(ray: Ray): Intersection {\n//             let denom = Vector.dot(norm, ray.dir);\n\n//             if (denom > 0) {\n//                 return null;\n//             }\n//             else {\n//                 let dist = (Vector.dot(norm, ray.start) + offset) / (-denom);\n//                 return { thing: this, ray: ray, dist: dist };\n//             }\n//         }\n//     }\n\n// }\n\n// namespace Surfaces {\n\n//     export let shiny: Surface = {\n//         diffuse: function(pos) { return Color.white; },\n//         specular: function(pos) { return Color.grey; },\n//         reflect: function(pos) { return 0.7; },\n//         roughness: 250\n//     }\n\n//     export let checkerboard: Surface = {\n//         diffuse: function(pos) {\n//             if ((Math.floor(pos.z) + Math.floor(pos.x)) % 2 !== 0) {\n//                 return Color.white;\n//             } else {\n//                 return Color.black;\n//             }\n//         },\n//         specular: function(pos) { return Color.white; },\n//         reflect: function(pos) {\n//             if ((Math.floor(pos.z) + Math.floor(pos.x)) % 2 !== 0) {\n//                 return 0.1;\n//             } else {\n//                 return 0.7;\n//             }\n//         },\n//         roughness: 150\n//     }\n\n// }\n\n\n// class RayTracer {\n\n//     private maxDepth = 5;\n\n//     private intersections(ray: Ray, scene: Scene) {\n//         let closest = +Infinity;\n//         let closestInter: Intersection = undefined;\n//         for (let i in scene.things) {\n//             let inter = scene.things[i].intersect(ray);\n//             if (inter != null && inter.dist < closest) {\n//                 closestInter = inter;\n//                 closest = inter.dist;\n//             }\n//         }\n//         return closestInter;\n//     }\n\n//     private testRay(ray: Ray, scene: Scene) {\n//         let isect = this.intersections(ray, scene);\n//         if (isect != null) {\n//             return isect.dist;\n//         } else {\n//             return undefined;\n//         }\n//     }\n\n//     private traceRay(ray: Ray, scene: Scene, depth: number): Color {\n//         let isect = this.intersections(ray, scene);\n//         if (isect === undefined) {\n//             return Color.background;\n//         } else {\n//             return this.shade(isect, scene, depth);\n//         }\n//     }\n\n//     private shade(isect: Intersection, scene: Scene, depth: number) {\n//         let d = isect.ray.dir;\n//         let pos = Vector.plus(Vector.times(isect.dist, d), isect.ray.start);\n//         let normal = isect.thing.normal(pos);\n//         let reflectDir = Vector.minus(d, Vector.times(2, Vector.times(Vector.dot(normal, d), normal)));\n//         let naturalColor = Color.plus(Color.background,\n//                                       this.getNaturalColor(isect.thing, pos, normal, reflectDir, scene));\n//         let reflectedColor = (depth >= this.maxDepth) ? Color.grey : this.getReflectionColor(isect.thing, pos, normal, reflectDir, scene, depth);\n//         return Color.plus(naturalColor, reflectedColor);\n//     }\n\n//     private getReflectionColor(thing: Thing, pos: Vector, normal: Vector, rd: Vector, scene: Scene, depth: number) {\n//         return Color.scale(thing.surface.reflect(pos), this.traceRay({ start: pos, dir: rd }, scene, depth + 1));\n//     }\n\n//     private getNaturalColor(thing: Thing, pos: Vector, norm: Vector, rd: Vector, scene: Scene) {\n//         let addLight = (col, light) => {\n//             let ldis = Vector.minus(light.pos, pos);\n//             let livec = Vector.norm(ldis);\n//             let neatIsect = this.testRay({ start: pos, dir: livec }, scene);\n//             let isInShadow = (neatIsect === undefined) ? false : (neatIsect <= Vector.mag(ldis));\n//             if (isInShadow) {\n//                 return col;\n//             }else {\n//                 let illum = Vector.dot(livec, norm);\n//                 let lcolor = (illum > 0) ? Color.scale(illum, light.color)\n//                                           : Color.defaultColor;\n//                 let specular = Vector.dot(livec, Vector.norm(rd));\n//                 let scolor = (specular > 0) ? Color.scale(Math.pow(specular, thing.surface.roughness), light.color)\n//                                           : Color.defaultColor;\n//                 return Color.plus(col, Color.plus(Color.times(thing.surface.diffuse(pos), lcolor),\n//                                                   Color.times(thing.surface.specular(pos), scolor)));\n//             }\n//         }\n//         return scene.lights.reduce(addLight, Color.defaultColor);\n//     }\n\n//     render(scene, ctx, screenWidth, screenHeight) {\n//         let getPoint = (x, y, camera) => {\n//             let recenterX = x => (x - (screenWidth / 2.0)) / 2.0 / screenWidth;\n//             let recenterY = y => -(y - (screenHeight / 2.0)) / 2.0 / screenHeight;\n//             return Vector.norm(Vector.plus(camera.forward, Vector.plus(Vector.times(recenterX(x), camera.right), Vector.times(recenterY(y), camera.up))));\n//         }\n//         for (let y = 0; y < screenHeight; y++) {\n//             for (let x = 0; x < screenWidth; x++) {\n//                 let color = this.traceRay({ start: scene.camera.pos, dir: getPoint(x, y, scene.camera) }, scene, 0);\n//                 let c = Color.toDrawingColor(color);\n//                 ctx.fillStyle = \"rgb(\" + String(c.r) + \", \" + String(c.g) + \", \" + String(c.b) + \")\";\n//                 ctx.fillRect(x, y, x + 1, y + 1);\n//             }\n//         }\n//     }\n\n// }\n\n\n// function defaultScene(): Scene {\n//     return {\n//         things: [new Plane(new Vector(0.0, 1.0, 0.0), 0.0, Surfaces.checkerboard),\n//                  new Sphere(new Vector(0.0, 1.0, -0.25), 1.0, Surfaces.shiny),\n//                  new Sphere(new Vector(-1.0, 0.5, 1.5), 0.5, Surfaces.shiny),\n//                  new Sphere(new Vector(0.6, 0.1, 1.9), 0.5, Surfaces.shiny)],\n//         lights: [{ pos: new Vector(-2.0, 2.5, 0.0), color: new Color(0.9, 0.07, 0.7) },\n//                  { pos: new Vector(1.5, 2.5, 1.5), color: new Color(0.07, 0.01, 0.9) },\n//                  { pos: new Vector(1.5, 0.5, -1.5), color: new Color(0.07, 0.49, 0.1) },\n//                  { pos: new Vector(0.0, 3.5, 0.0), color: new Color(0.91, 0.21, 0.5) }],\n//         camera: new Camera(new Vector(3.0, 2.0, 4.0), new Vector(-1.0, 0.5, 0.0))\n//     };\n// }\n\n// export default function exec() {\n//     let canv = document.createElement(\"canvas\");\n//     canv.width = 256;\n//     canv.height = 256;\n//     document.body.appendChild(canv);\n//     let ctx = canv.getContext(\"2d\");\n//     let rayTracer = new RayTracer();\n//     return rayTracer.render(defaultScene(), ctx, 256, 256);\n// }\n\n"]}